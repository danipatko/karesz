@* nav here *@

<FluentStack HorizontalGap="20" Style="padding: 1rem; padding-bottom: 0;" VerticalAlignment="VerticalAlignment.Center">
	<FluentButton IconStart="@(new Icons.Filled.Size20.CaretRight())"
				  Appearance="Appearance.Accent"
				  Loading="@IsRunning"
				  OnClick="@Run">
		Compile and Run
	</FluentButton>
	<FluentButton IconStart="@(new Icons.Filled.Size16.CheckboxUnchecked())"
				  Appearance="Appearance.Neutral"
				  Disabled="@(!IsRunning)"
				  OnClick="@Stop">
		Stop
	</FluentButton>

	<FluentDivider Style="height: 30px;" Role="DividerRole.Presentation" Orientation="Orientation.Vertical"></FluentDivider>

	<FluentSelect Height="50vh" TOption="string" Items=@Core.Level.LEVEL_NAMES SelectedOptionChanged="@OnLevelSelected" Value=@(Core.Robot.CurrentLevel.LevelName) /> 

	<FluentSwitch Style="width: 150px;" @bind-Value="@DisplayHeatmap">Heatmap</FluentSwitch>

</FluentStack>

@* stuff *@
<div class="center-content">
	<style> @(DisplayHeatmap ? HeatStyle : string.Empty) </style>
	<FluentHorizontalScroll Speed="600" Easing=ScrollEasing.EaseInOut>
		<div class="game-container" style="--tile-size: 20px; /*calc((100% - 2rem) / 41);*/">
			<Level />

			@foreach (var item in Positions)
			{
				<Karesz Position=@item.Position Name=@item.Name />
			}

			@foreach ((int x, int y, Core.Level.Tile tile) in Stones)
			{
				<Stone X=@x Y=@y Tile=@tile />
			}
		</div>
	</FluentHorizontalScroll>
</div>

@code {
	[Inject] public HttpClient HttpClient { get; set; }

	private RobotInfo[] Positions { get; set; } = [];

	private (int x, int y, Core.Level.Tile tile)[] Stones { get; set; } = [];

	private bool IsRunning { get; set; } = false;

	private string HeatStyle { get; set; } = string.Empty;

	CancellationTokenSource cts = new();

	protected override void OnInitialized()
	{
		// register game renderer
		Core.Game.RenderFunction = async delegate (RobotInfo[] positions, (int x, int y, Core.Level.Tile tile)[]? map)
		{
			// make sure we are running in the UI sync context
			await InvokeAsync(() =>
			{
				Positions = positions;

				if (map != null)
					Stones = map;

				StateHasChanged();
			});
		};
	}

	private async Task Run()
	{
		cts = new();
		IsRunning = true;

		await Core.Game.StartAsync(cts.Token)
			.ContinueWith(_ =>
			{
				IsRunning = false;
				Console.WriteLine(Output.Content);
				Output.Flush();
			});
	}

	private string RGBScale(float value, float min = 0, float max = 1)
	{
		var ratio = 2 * (value - min) / (max - min);
		var b = (int)Math.Max(0, 255 * (1 - ratio));
		var r = (int)Math.Max(0, 255 * (ratio - 1));
		var g = 255 - b - r;
		return $"rgb({r}, {g}, {b})";
	}

	private async Task Stop() => await cts.CancelAsync();

	// ---------- 

	private bool DisplayHeatmap = false;

	private async Task OnLevelSelected(string levelName)
	{
		var level = await Core.Level.LoadAsync(HttpClient, levelName);
		// TODO: alert
		if (level == null)
		{
			return;
		}

		Stones = level.Enumerate().ToArray();
		HeatStyle = string.Join("\n", level.EnumerateHeat().Select((a) => $".tile.x{a.x}.y{a.y} {{ background-color: {RGBScale(a.h, max: 700f)} !important; }}"));
		StateHasChanged();
	}
}

